fun get_handle(first) do
    lambda (last) do
        first ++ ' ' ++ last
    end
end

afn = get_handle('drax')
res = afn('lang')

assert(res == 'drax lang', 'fail to make lambda')

fun exec_fn(call) do
    call("lambda function")
end

ff = exec_fn(lambda (val) do
    'my drax ' ++ val
end)

assert(ff == 'my drax lambda function', 'fail to pass lambda as argument')

## pass lambda to lambda factory
## nested lambdas and lamda factory
fun exec_fn2(fixed_arg) do
    lambda (call) do
        call(fixed_arg)
    end
end

ff2 = exec_fn2('fixed argument!')

resff2 = ff2(lambda (myArg) do
    'my ' ++ myArg
end)

assert(resff2 == 'my fixed argument!', 'fail to pass labda to function created by function')

## call native function inside factory

fun get_handle(value) do
    lambda (key) do
        Frame.put({}, key, value)
    end
end

afn = get_handle('val')
res = afn('myk')
assert(res == {myk: "val"}, 'fail to make lambda')


## pass lambda to factory function
## 1. first problem
# fun exec_fn3(call) do
#     lambda (val) do
#         call(val) + " working on main function!"
#     end
# end

# ff3 = exec_fn3(lambda (arg) do
#      "pass lambda 1," ++ arg
# end)

# resff3 = ff3('receiving arg 1')
# print(resff3)
# assert(resff3 == 'my fixed argument!', 'fail to pass labda to function created by function')


## problem 2
# fun get_handle(name1) do
#     lambda (name2) do
#         lambda (name3) do
#             lambda (name4) do
#                 name1 ++ ' ' ++ name2 ++ ' ' name3 ++ ' ' name4
#             end
#         end
#     end
# end

# a = get_handle('one')
# b = a('two')
# c = b('two')
# d = c('three')
# print(d)
# assert(d == 'drax lang', 'fail to make lambda')



print("lambda's done!")
